name: Persistent Cloudflare Runner

on:
  workflow_dispatch:
  schedule:
    - cron: '0 */5 * * *' # Backup trigger every 5 hours

jobs:
  run-service:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Cloudflared
        run: |
          curl -L --output cloudflared.deb https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared.deb

      - name: Start Server & Tunnel
        run: |
          # Start your actual server here (e.g., python3 server.py &)
          # For demo purposes, we'll start a simple python http server
          python3 -m http.server 8080 &

          # Start Cloudflare Tunnel
          # NOTE: For a permanent domain, you would use: cloudflared tunnel run --token ${{ secrets.CLOUDFLARE_TOKEN }}
          # For this free/temp version, we use 'tunnel --url' which gives a random trycloudflare.com URL
          cloudflared tunnel --url http://localhost:8080 > tunnel_log.txt 2>&1 &

          echo "Waiting for tunnel URL..."
          sleep 10
          cat tunnel_log.txt
          echo "Tunnel URL above ^"

      - name: "Start Keepalive Loop & SSH"
        env:
          GH_TOKEN: ${{ secrets.MY_SECRET_PAT }}
          REPO: ${{ github.repository }}
          # Extract branch name from GITHUB_REF (refs/heads/main -> main)
          REF: ${{ github.ref_name }}
        run: |
          # 1. Start the Daisy-Chain Timer in the BACKGROUND
          # We use a background subshell so it doesn't block the SSH session
          (
            echo "Keepalive timer started (5h 50m)..."
            sleep 21000 # 5h 50m

            echo "Triggering next workflow..."
            curl -X POST \
              -H "Authorization: token $GH_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/$REPO/actions/workflows/persistent_runner.yml/dispatches" \
              -d "{\"ref\":\"$REF\"}"

            echo "Next workflow triggered."
          ) &
          # Save the PID of the background process so we can wait for it later
          echo $! > keepalive_pid.txt

      # 2. Start Tmate (Blocks here until connection closes or timeout)
      - name: Setup Tmate Session
        uses: mxschmitt/action-tmate@v3
        with:
          limit-access-to-actor: true # Only YOU can SSH in (uses your GitHub public keys)

      # 3. Wait for Keepalive (if Tmate is closed early)
      - name: Wait for Keepalive
        if: always()
        run: |
          PID=$(cat keepalive_pid.txt)
          echo "Waiting for Keepalive timer (PID $PID) to finish..."
          # Start a wait loop that checks if the process is still running
          while kill -0 $PID 2>/dev/null; do
            sleep 10
          done
          echo "Keepalive timer finished. Exiting."
